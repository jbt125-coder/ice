<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cyberpunk Carnival Chaos</title>
    <style>
        * { box-sizing: border-box; }
        body, html { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            overflow: hidden; 
            background: #0a0a0a;
            font-family: 'Courier New', monospace;
            touch-action: none;
        }

        /* Cyberpunk Theme */
        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #1a0033 0%, #0d0d0d 50%, #001a1a 100%);
            color: #00ff88; display: flex; flex-direction: column; 
            align-items: center; justify-content: flex-start;
            z-index: 200; text-align: center; padding: 20px;
            overflow-y: auto;
            border: 2px solid #ff00ff;
            box-shadow: inset 0 0 50px rgba(255,0,255,0.3);
        }

        .overlay h1 { 
            font-size: 42px; margin: 20px 0; 
            text-shadow: 0 0 20px #00ff88, 0 0 40px #00ff88;
            color: #00ff88;
            animation: glitch 3s infinite;
        }
        .overlay h2 { 
            font-size: 28px; margin: 15px 0; 
            color: #ff00ff;
            text-shadow: 0 0 10px #ff00ff;
        }
        .overlay h3 { 
            font-size: 22px; margin: 10px 0; 
            color: #00ddff;
            text-shadow: 0 0 10px #00ddff;
        }
        .overlay p { font-size: 16px; margin: 10px 0; opacity: 0.9; color: #aaa; }

        @keyframes glitch {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-2px); }
            40% { transform: translateX(2px); }
            60% { transform: translateX(-2px); }
            80% { transform: translateX(2px); }
        }

        button {
            padding: 15px 30px; margin: 10px; border-radius: 5px; 
            border: 2px solid #00ff88;
            background: rgba(0,255,136,0.2);
            font-weight: bold; font-size: 18px; cursor: pointer;
            box-shadow: 0 0 20px rgba(0,255,136,0.5);
            transition: all 0.2s;
            color: #00ff88;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
        }
        button:hover { 
            background: rgba(0,255,136,0.4);
            box-shadow: 0 0 30px rgba(0,255,136,0.8);
        }
        button:active { transform: scale(0.95); }
        button:disabled { 
            opacity: 0.3; cursor: not-allowed; 
            box-shadow: none;
        }

        .btn-small { padding: 8px 15px; font-size: 14px; margin: 5px; }
        .btn-large { padding: 20px 40px; font-size: 24px; }
        .btn-green { border-color: #00ff88; color: #00ff88; }
        .btn-red { border-color: #ff0066; color: #ff0066; box-shadow: 0 0 20px rgba(255,0,102,0.5); }
        .btn-blue { border-color: #00ddff; color: #00ddff; box-shadow: 0 0 20px rgba(0,221,255,0.5); }

        input[type="file"] {
            margin: 10px; padding: 10px; border-radius: 5px;
            background: rgba(0,0,0,0.8); font-size: 14px;
            border: 2px solid #00ff88;
            color: #00ff88;
        }

        select, input[type="text"] {
            margin: 10px; padding: 12px; border-radius: 5px;
            border: 2px solid #00ff88; font-size: 16px; width: 80%; max-width: 400px;
            background: rgba(0,0,0,0.8);
            color: #00ff88;
            font-family: 'Courier New', monospace;
        }

        /* Game Container */
        #game-container { 
            position: relative; width: 100vw; height: 100vh; 
            background: linear-gradient(180deg, #0d0d1a 0%, #1a0033 50%, #000 100%);
            display: none; 
        }

        /* Scanlines effect */
        #game-container::before {
            content: '';
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0,0,0,0.15),
                rgba(0,0,0,0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 1000;
        }

        /* UI Elements */
        #game-ui {
            position: absolute; top: 0; left: 0; width: 100%; padding: 15px;
            display: flex; justify-content: space-between; align-items: flex-start;
            z-index: 50; pointer-events: none;
        }

        #left-ui, #right-ui { 
            background: rgba(0,0,0,0.8); padding: 15px; 
            border-radius: 5px; 
            border: 2px solid #00ff88;
            box-shadow: 0 0 20px rgba(0,255,136,0.3);
        }

        #score-display { font-size: 24px; font-weight: bold; color: #00ff88; margin: 5px 0; text-shadow: 0 0 10px #00ff88; }
        #combo-display { font-size: 18px; color: #ff00ff; margin: 5px 0; text-shadow: 0 0 10px #ff00ff; }
        #level-display { font-size: 20px; font-weight: bold; color: #00ddff; margin: 5px 0; text-shadow: 0 0 10px #00ddff; }
        #timer-display { font-size: 22px; font-weight: bold; color: #ff0066; margin: 5px 0; text-shadow: 0 0 10px #ff0066; }

        /* Ammo Display */
        #ammo-display {
            position: absolute; bottom: 240px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.9); padding: 15px 25px;
            border-radius: 10px; border: 2px solid #ff00ff;
            box-shadow: 0 0 30px rgba(255,0,255,0.5);
            z-index: 60; font-size: 20px; color: #ff00ff;
            text-shadow: 0 0 10px #ff00ff;
        }

        #ammo-bars {
            display: flex; gap: 8px; margin-top: 10px;
        }

        .ammo-bar {
            width: 40px; height: 8px; background: rgba(255,0,255,0.2);
            border: 1px solid #ff00ff; border-radius: 3px;
            position: relative; overflow: hidden;
        }

        .ammo-bar.active {
            background: #ff00ff;
            box-shadow: 0 0 10px #ff00ff;
            animation: ammo-pulse 0.5s;
        }

        @keyframes ammo-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .ammo-bar.reloading::after {
            content: '';
            position: absolute;
            left: 0; top: 0; height: 100%;
            background: #ff00ff;
            animation: reload-fill 2s linear;
        }

        @keyframes reload-fill {
            0% { width: 0%; }
            100% { width: 100%; }
        }

        /* Projectile Selector */
        #projectile-selector {
            position: absolute; bottom: 180px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.9); padding: 10px 20px;
            border-radius: 10px; display: flex; gap: 10px;
            border: 2px solid #00ff88;
            box-shadow: 0 0 30px rgba(0,255,136,0.3); z-index: 60;
        }

        .projectile-btn {
            font-size: 40px; padding: 10px; background: rgba(0,255,136,0.1); 
            border: 3px solid transparent;
            border-radius: 10px; cursor: pointer; transition: all 0.2s; margin: 0;
            box-shadow: none; width: 60px; height: 60px; display: flex;
            align-items: center; justify-content: center;
        }

        .projectile-btn.active { 
            border-color: #00ff88; background: rgba(0,255,136,0.3);
            transform: scale(1.15);
            box-shadow: 0 0 20px rgba(0,255,136,0.8);
        }

        .projectile-btn.suggested {
            border-color: #ff00ff; animation: pulse 1s infinite;
            box-shadow: 0 0 20px rgba(255,0,255,0.8);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* Target Characters */
        .character {
            position: absolute; 
            width: 150px; height: 150px;
            border-radius: 10px; 
            box-shadow: 0 0 30px rgba(0,255,136,0.5);
            z-index: 10; transition: all 0.3s;
            border: 2px solid #00ff88;
        }

        .character.boss {
            width: 250px; height: 250px;
            box-shadow: 0 0 50px rgba(255,0,255,0.8);
            border: 3px solid #ff00ff;
        }

        .character-img {
            width: 100%; height: 100%; object-fit: cover;
            border-radius: 10px; position: absolute; top: 0; left: 0;
        }

        .character-reaction {
            width: 100%; height: 100%; object-fit: cover;
            border-radius: 10px; position: absolute; top: 0; left: 0;
            opacity: 0; transition: opacity 0.3s;
        }

        .character.reacting .character-reaction {
            opacity: 1;
        }

        .character-emoji {
            font-size: 120px; text-align: center; 
            line-height: 150px; position: absolute;
            width: 100%; height: 100%;
            filter: drop-shadow(0 0 20px #00ff88);
        }

        .character.boss .character-emoji {
            font-size: 180px; line-height: 250px;
        }

        .character-need {
            position: absolute; top: -50px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.9); padding: 8px 15px; border-radius: 10px;
            border: 2px solid #ff00ff;
            box-shadow: 0 0 20px rgba(255,0,255,0.5); font-size: 24px;
            white-space: nowrap; z-index: 11;
        }

        .character-progress {
            position: absolute; bottom: -30px; left: 10%; width: 80%;
            height: 15px; background: rgba(0,0,0,0.8);
            border-radius: 5px; overflow: hidden; 
            border: 2px solid #00ff88;
            box-shadow: 0 0 10px rgba(0,255,136,0.3);
        }

        .character-progress-fill {
            height: 100%; background: linear-gradient(90deg, #00ff88 0%, #00ddff 100%);
            transition: width 0.3s; border-radius: 3px;
            box-shadow: 0 0 15px #00ff88;
        }

        /* Zone Markers (on character) - MUCH BRIGHTER */
        .zone-marker {
            position: absolute; width: 50px; height: 50px;
            border: 4px solid; border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
            z-index: 12; animation: zone-glow 2s infinite;
        }

        .zone-marker.upper { 
            border-color: #00ff88; 
            background: rgba(0,255,136,0.4);
            box-shadow: 0 0 20px #00ff88, inset 0 0 20px #00ff88;
        }
        .zone-marker.middle { 
            border-color: #00ddff; 
            background: rgba(0,221,255,0.4);
            box-shadow: 0 0 20px #00ddff, inset 0 0 20px #00ddff;
        }
        .zone-marker.lower { 
            border-color: #ff0066; 
            background: rgba(255,0,102,0.4);
            box-shadow: 0 0 20px #ff0066, inset 0 0 20px #ff0066;
        }

        @keyframes zone-glow {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }

        /* Glitchy Holographic Slingshot */
        #slingshot-base {
            position: absolute; bottom: 60px; left: 50%; transform: translateX(-50%);
            width: 100px; height: 120px; z-index: 40;
        }

        #slingshot-hologram {
            position: absolute; bottom: 80px; left: 50%;
            width: 30px; height: 30px; 
            background: radial-gradient(circle, #00ff88, transparent);
            border-radius: 50%;
            transform: translateX(-50%); z-index: 41; 
            box-shadow: 0 0 30px #00ff88, 0 0 60px #00ff88;
            animation: hologram-flicker 3s infinite;
        }

        @keyframes hologram-flicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
            25%, 75% { opacity: 0.9; }
        }

        .band {
            position: absolute; height: 4px; 
            background: linear-gradient(90deg, #00ff88, #00ddff);
            transform-origin: left center; z-index: 39; border-radius: 2px;
            display: none; 
            box-shadow: 0 0 10px #00ff88;
        }

        /* Projectiles */
        .projectile { 
            position: absolute; font-size: 50px; z-index: 45; 
            transform: translate(-50%, -50%); 
            filter: drop-shadow(0 0 15px #00ff88);
        }

        .ghost { 
            opacity: 0.5; pointer-events: none; position: absolute; 
            font-size: 50px; z-index: 44; transform: translate(-50%, -50%); 
            filter: drop-shadow(0 0 20px #ff00ff);
        }

        .trajectory-dot {
            position: absolute; width: 8px; height: 8px; 
            background: #00ff88; border-radius: 50%;
            z-index: 38; pointer-events: none;
            box-shadow: 0 0 10px #00ff88;
            animation: dot-fade 0.5s;
        }

        @keyframes dot-fade {
            0% { opacity: 0; }
            100% { opacity: 0.8; }
        }

        /* Floating Text */
        .floating-text {
            position: absolute; font-size: 32px; font-weight: bold;
            z-index: 100; pointer-events: none; animation: float-up 1.5s ease-out;
        }

        @keyframes float-up {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-100px); }
        }

        /* Image Grid */
        .image-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px; max-width: 1000px; margin: 20px auto; max-height: 60vh;
            overflow-y: auto; padding: 20px; width: 100%;
        }

        .image-slot {
            border: 3px dashed rgba(0,255,136,0.3); border-radius: 10px;
            padding: 15px; text-align: center; background: rgba(0,0,0,0.5);
            transition: all 0.3s;
        }

        .image-slot.filled {
            border: 3px solid #00ff88; 
            background: rgba(0,255,136,0.1);
            box-shadow: 0 0 20px rgba(0,255,136,0.3);
        }

        .image-preview {
            width: 100%; height: 100px; object-fit: cover;
            border-radius: 5px; margin: 5px 0;
            border: 2px solid #00ff88;
        }

        .slot-label {
            font-size: 16px; font-weight: bold; margin: 5px 0;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
        }

        /* Zone Editor */
        #zone-editor-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 300;
            display: none; flex-direction: column; align-items: center;
            justify-content: center; padding: 20px;
            border: 4px solid #ff00ff;
        }

        #zone-editor-canvas-container {
            position: relative; max-width: 90vw; max-height: 70vh;
            background: rgba(0,0,0,0.8); border-radius: 10px; padding: 10px;
            box-shadow: 0 0 40px rgba(255,0,255,0.5);
            border: 2px solid #ff00ff;
        }

        #zone-editor-canvas {
            max-width: 100%; max-height: 100%; display: block;
            cursor: crosshair; border-radius: 5px;
        }

        #zone-editor-instructions {
            background: rgba(0,0,0,0.9); padding: 20px;
            border-radius: 10px; margin-bottom: 20px; max-width: 600px;
            border: 2px solid #00ff88;
            box-shadow: 0 0 30px rgba(0,255,136,0.3);
        }

        .zone-dot {
            position: absolute; width: 60px; height: 60px;
            border: 5px solid; border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
            animation: zone-pulse 1.5s infinite;
        }

        .zone-dot.upper { 
            border-color: #00ff88; 
            background: rgba(0,255,136,0.3);
            box-shadow: 0 0 30px #00ff88;
        }
        .zone-dot.middle { 
            border-color: #00ddff; 
            background: rgba(0,221,255,0.3);
            box-shadow: 0 0 30px #00ddff;
        }
        .zone-dot.lower { 
            border-color: #ff0066; 
            background: rgba(255,0,102,0.3);
            box-shadow: 0 0 30px #ff0066;
        }

        @keyframes zone-pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.15); }
        }

        /* Voice Recording Panel */
        .voice-panel {
            background: rgba(0,0,0,0.7); padding: 15px;
            border-radius: 10px; margin: 10px; max-width: 600px; width: 100%;
            border: 2px solid #00ff88;
            box-shadow: 0 0 20px rgba(0,255,136,0.3);
        }

        .voice-row {
            display: flex; align-items: center; justify-content: space-between;
            margin: 10px 0; padding: 10px; background: rgba(0,255,136,0.1);
            border-radius: 5px; flex-wrap: wrap;
        }

        .recording-indicator {
            display: inline-block; width: 12px; height: 12px;
            background: #ff0066; border-radius: 50%; margin-left: 10px;
            animation: blink 1s infinite;
            box-shadow: 0 0 10px #ff0066;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* Hidden Elements */
        #yt-player { position: absolute; width: 1px; height: 1px; opacity: 0; }
        .hidden { display: none !important; }

        /* Scrollbar Styling */
        ::-webkit-scrollbar { width: 10px; }
        ::-webkit-scrollbar-track { background: rgba(0,0,0,0.5); border-radius: 5px; }
        ::-webkit-scrollbar-thumb { background: rgba(0,255,136,0.5); border-radius: 5px; }
    </style>
</head>
<body>

<div id="yt-player"></div>

<!-- WELCOME SCREEN -->
<div id="welcome-screen" class="overlay">
    <h1>‚ö° CYBERPUNK CARNIVAL CHAOS ‚ö°</h1>
    <p style="color: #ff00ff;">A dystopian grunge carnival shooter</p>
    <p style="font-size: 14px; max-width: 400px; color: #aaa;">
        This game requires <b style="color: #00ff88;">microphone</b> access for voice recordings
        and <b style="color: #00ff88;">photo uploads</b> for custom targets.
        All data remains local.
    </p>
    <button class="btn-large btn-green" onclick="showSetup()">INITIALIZE SYSTEM</button>
</div>

<!-- SETUP SCREEN -->
<div id="setup-screen" class="overlay hidden">
    <h2>üì∏ CONFIGURE TARGETS</h2>
    <p>For each level, select preset emoji OR upload 2 custom images:</p>
    <p style="font-size: 14px; opacity: 0.9; max-width: 500px;">
        <b style="color: #00ff88;">Custom Images Need:</b><br>
        1Ô∏è‚É£ NEUTRAL image (default state)<br>
        2Ô∏è‚É£ REACTION image (displayed on hit - 0.5 sec)<br>
        3Ô∏è‚É£ Mark 3 hit zones on neutral image
    </p>
    
    <div class="image-grid" id="image-grid"></div>
    
    <button class="btn-large btn-green" onclick="showVoiceSetup()" id="continue-voice-btn" disabled>
        PROCEED TO AUDIO CONFIG ‚Üí
    </button>
</div>

<!-- ZONE EDITOR MODAL -->
<div id="zone-editor-modal">
    <div id="zone-editor-instructions">
        <h3 style="margin-top: 0; color: #00ff88;">üéØ MARK TARGET ZONES</h3>
        <p style="color: #aaa; font-size: 14px;">
            Click 3 locations on your target:<br>
            <span style="color: #00ff88;">‚óè</span> <b>UPPER ZONE</b> (Head/Mouth) - catches treats<br>
            <span style="color: #00ddff;">‚óè</span> <b>MIDDLE ZONE</b> (Hands/Chest) - catches gifts<br>
            <span style="color: #ff0066;">‚óè</span> <b>LOWER ZONE</b> (Body/Legs) - impact zone<br><br>
            <b style="color: #ff00ff;">TIP:</b> Click "RESET" anytime to restart!
        </p>
        <div id="zone-status" style="color: #00ff88; font-weight: bold; font-size: 16px; margin: 10px 0;">
            MARK: <span id="current-zone-name" style="color: #00ff88;">UPPER ZONE</span>
        </div>
    </div>
    
    <div id="zone-editor-canvas-container">
        <img id="zone-editor-canvas" src="" alt="Zone Editor">
    </div>
    
    <div style="margin-top: 20px;">
        <button class="btn-small btn-red" onclick="resetZones()">‚Ü∫ RESET ZONES</button>
        <button class="btn-large btn-green" onclick="saveZones()" id="save-zones-btn" disabled>
            ‚úì SAVE ZONES
        </button>
    </div>
</div>

<!-- VOICE SETUP SCREEN -->
<div id="voice-setup-screen" class="overlay hidden">
    <h2>üé§ CONFIGURE AUDIO RESPONSES</h2>
    <p>Record unique voice reactions for each target</p>
    
    <div style="max-height: 70vh; overflow-y: auto; width: 100%; max-width: 700px;">
        <div id="voice-panels"></div>
    </div>
    
    <button class="btn-large btn-green" onclick="showMusicSetup()">
        PROCEED TO MUSIC CONFIG ‚Üí
    </button>
</div>

<!-- MUSIC SETUP SCREEN -->
<div id="music-setup-screen" class="overlay hidden">
    <h2>üéµ BACKGROUND AUDIO</h2>
    <p>Configure background music track</p>
    
    <h3>YouTube Video ID:</h3>
    <input type="text" id="youtube-id" value="rog8ou-ZepE" placeholder="Enter YouTube video ID">
    <p style="font-size: 12px;">Default: Cyberpunk ambient</p>
    
    <div style="margin: 20px 0;">
        <button class="btn-small btn-blue" onclick="testMusic()">‚ñ∂Ô∏è TEST</button>
        <button class="btn-small btn-red" onclick="stopMusic()">‚èπÔ∏è STOP</button>
    </div>
    
    <button class="btn-large btn-green" onclick="startGame()">
        üéÆ LAUNCH GAME!
    </button>
</div>

<!-- GAME CONTAINER -->
<div id="game-container">
    <div id="game-ui">
        <div id="left-ui">
            <div id="score-display">SCORE: 0</div>
            <div id="combo-display">COMBO: 0x</div>
        </div>
        <div id="right-ui">
            <div id="level-display">LEVEL: 1</div>
            <div id="timer-display">TIME: 30</div>
        </div>
    </div>

    <div id="ammo-display">
        <div>MAGAZINE: <span id="ammo-count">5/5</span></div>
        <div id="ammo-bars">
            <div class="ammo-bar active"></div>
            <div class="ammo-bar active"></div>
            <div class="ammo-bar active"></div>
            <div class="ammo-bar active"></div>
            <div class="ammo-bar active"></div>
        </div>
    </div>

    <div id="projectile-selector">
        <button class="projectile-btn" data-type="poop" onclick="selectProjectile('poop')">üí©</button>
        <button class="projectile-btn" data-type="baseball" onclick="selectProjectile('baseball')">‚öæ</button>
        <button class="projectile-btn active" data-type="candy" onclick="selectProjectile('candy')">üç¨</button>
        <button class="projectile-btn" data-type="toy" onclick="selectProjectile('toy')">üß∏</button>
        <button class="projectile-btn" data-type="gift" onclick="selectProjectile('gift')">üéÅ</button>
        <button class="projectile-btn" data-type="ball" onclick="selectProjectile('ball')">‚öΩ</button>
        <button class="projectile-btn" data-type="balloon" onclick="selectProjectile('balloon')">üéà</button>
    </div>

    <div id="slingshot-base">
        <!-- Glitchy holographic frame -->
        <svg width="100" height="120" viewBox="0 0 100 120" style="filter: drop-shadow(0 0 20px #00ff88);">
            <path d="M 30 120 L 30 30 Q 30 15, 40 15 L 60 15 Q 70 15, 70 30 L 70 120" 
                  fill="none" stroke="#00ff88" stroke-width="3" opacity="0.6"/>
            <ellipse cx="50" cy="15" rx="15" ry="10" fill="none" stroke="#00ddff" stroke-width="2" opacity="0.8"/>
            <!-- Glitch lines -->
            <line x1="25" y1="40" x2="35" y2="40" stroke="#ff00ff" stroke-width="2" opacity="0.5"/>
            <line x1="65" y1="60" x2="75" y2="60" stroke="#ff00ff" stroke-width="2" opacity="0.5"/>
        </svg>
    </div>
    <div id="slingshot-hologram"></div>
    <div id="band-l" class="band"></div>
    <div id="band-r" class="band"></div>
</div>

<!-- LEVEL COMPLETE SCREEN -->
<div id="level-complete-screen" class="overlay hidden">
    <h1>üéâ LEVEL COMPLETE üéâ</h1>
    <div id="level-stats"></div>
    <button class="btn-large btn-green" onclick="nextLevel()">NEXT LEVEL ‚Üí</button>
</div>

<!-- GAME OVER SCREEN -->
<div id="game-over-screen" class="overlay hidden">
    <h1>‚è∞ TIME EXPIRED</h1>
    <div id="game-over-stats"></div>
    <button class="btn-large btn-green" onclick="restartGame()">RETRY</button>
    <button class="btn-large btn-blue" onclick="location.reload()">MAIN MENU</button>
</div>

<!-- VICTORY SCREEN -->
<div id="victory-screen" class="overlay hidden">
    <h1>üèÜ SYSTEM COMPLETE üèÜ</h1>
    <div id="victory-stats"></div>
    <button class="btn-large btn-green" onclick="location.reload()">RESTART</button>
</div>

<script>
// =========================
// GAME STATE
// =========================
const gameState = {
    characters: [],
    currentLevel: 1,
    score: 0,
    combo: 0,
    timeLeft: 30,
    activeCharacters: [],
    selectedProjectile: 'candy',
    projectileEmojis: {
        poop: 'üí©', baseball: '‚öæ', candy: 'üç¨', 
        toy: 'üß∏', gift: 'üéÅ', ball: '‚öΩ', balloon: 'üéà'
    },
    zoneNeeds: {
        upper: ['candy', 'gift', 'balloon'],
        middle: ['toy', 'gift', 'ball'],
        lower: ['poop', 'baseball']
    },
    musicId: 'rog8ou-ZepE',
    player: null,
    timerInterval: null,
    trajectoryDots: [],
    
    // Magazine system
    ammo: 5,
    maxAmmo: 5,
    isReloading: false,
    
    // Zone editor
    currentEditingChar: null,
    zoneEditorImage: null,
    markedZones: {},
    currentZoneToMark: 'upper'
};

const presetCharacters = [
    {emoji: 'üòä', name: 'Happy'},
    {emoji: 'üòé', name: 'Cool'},
    {emoji: 'ü§†', name: 'Cowboy'},
    {emoji: 'ü§ñ', name: 'Robot'},
    {emoji: 'üëΩ', name: 'Alien'},
    {emoji: 'üê∂', name: 'Dog'},
    {emoji: 'üê±', name: 'Cat'},
    {emoji: 'ü¶Å', name: 'Lion'},
    {emoji: 'üêº', name: 'Panda'},
    {emoji: 'üê∏', name: 'Frog'}
];

// =========================
// YOUTUBE API
// =========================
var tag = document.createElement('script');
tag.src = "https://www.youtube.com/iframe_api";
document.head.appendChild(tag);

function onYouTubeIframeAPIReady() {
    gameState.player = new YT.Player('yt-player', {
        height: '1', width: '1',
        videoId: gameState.musicId,
        playerVars: { 'autoplay': 0, 'loop': 1, 'playlist': gameState.musicId },
        events: { 
            'onReady': (e) => e.target.setVolume(30)
        }
    });
}

function testMusic() {
    const id = document.getElementById('youtube-id').value.trim();
    if (gameState.player && id) {
        gameState.player.loadVideoById(id);
        gameState.player.playVideo();
        gameState.musicId = id;
    }
}

function stopMusic() {
    if (gameState.player) gameState.player.pauseVideo();
}

// =========================
// SETUP FLOW
// =========================
function showSetup() {
    document.getElementById('welcome-screen').classList.add('hidden');
    document.getElementById('setup-screen').classList.remove('hidden');
    generateImageGrid();
}

function generateImageGrid() {
    const grid = document.getElementById('image-grid');
    grid.innerHTML = '';
    
    for (let i = 0; i < 10; i++) {
        const slot = document.createElement('div');
        slot.className = 'image-slot';
        slot.innerHTML = `
            <div class="slot-label">${i === 9 ? 'üî• BOSS' : 'LVL ' + (i + 1)}</div>
            <div style="font-size: 60px; height: 100px; display: flex; align-items: center; justify-content: center;">
                ${presetCharacters[i].emoji}
            </div>
            <button class="btn-small" onclick="uploadCharacterImages(${i})">üì∏ CUSTOM</button>
            <button class="btn-small btn-green" onclick="usePreset(${i})">‚úì PRESET</button>
        `;
        grid.appendChild(slot);
    }
}

function usePreset(index) {
    const preset = presetCharacters[index];
    gameState.characters[index] = {
        neutralImg: null,
        reactionImg: null,
        emoji: preset.emoji,
        name: preset.name,
        level: index + 1,
        isBoss: index === 9,
        zones: autoDetectZones(),
        voices: { hit: null }
    };
    updateImageSlot(index);
    checkSetupComplete();
}

function autoDetectZones() {
    return {
        upper: { x: 50, y: 30 },
        middle: { x: 50, y: 50 },
        lower: { x: 50, y: 70 }
    };
}

function uploadCharacterImages(index) {
    const neutralInput = document.createElement('input');
    neutralInput.type = 'file';
    neutralInput.accept = 'image/*';
    
    neutralInput.onchange = (e) => {
        const neutralFile = e.target.files[0];
        if (!neutralFile) return;
        
        const reader1 = new FileReader();
        reader1.onload = (event1) => {
            const reactionInput = document.createElement('input');
            reactionInput.type = 'file';
            reactionInput.accept = 'image/*';
            
            setTimeout(() => {
                alert('Neutral image uploaded! Now select the REACTION image (shown when hit).');
                reactionInput.click();
            }, 100);
            
            reactionInput.onchange = (e2) => {
                const reactionFile = e2.target.files[0];
                if (!reactionFile) return;
                
                const reader2 = new FileReader();
                reader2.onload = (event2) => {
                    gameState.characters[index] = {
                        neutralImg: event1.target.result,
                        reactionImg: event2.target.result,
                        emoji: null,
                        name: neutralFile.name.split('.')[0],
                        level: index + 1,
                        isBoss: index === 9,
                        zones: null,
                        voices: { hit: null }
                    };
                    
                    updateImageSlot(index);
                    openZoneEditor(index);
                };
                reader2.readAsDataURL(reactionFile);
            };
        };
        reader1.readAsDataURL(neutralFile);
    };
    
    alert('First, select the NEUTRAL image (default state of character).');
    neutralInput.click();
}

function updateImageSlot(index) {
    const slots = document.querySelectorAll('.image-slot');
    const char = gameState.characters[index];
    
    if (char) {
        slots[index].classList.add('filled');
        
        if (char.neutralImg) {
            slots[index].innerHTML = `
                <div class="slot-label">${char.isBoss ? 'üî• BOSS' : 'LVL ' + char.level}</div>
                <img src="${char.neutralImg}" class="image-preview" alt="Neutral">
                <img src="${char.reactionImg}" class="image-preview" alt="Reaction">
                <button class="btn-small btn-blue" onclick="openZoneEditor(${index})">üéØ ZONES</button>
                <button class="btn-small btn-red" onclick="removeCharacter(${index})">‚úï</button>
            `;
        } else {
            slots[index].innerHTML = `
                <div class="slot-label">${char.isBoss ? 'üî• BOSS' : 'LVL ' + char.level}</div>
                <div style="font-size: 60px; height: 100px; display: flex; align-items: center; justify-content: center;">
                    ${char.emoji}
                </div>
                <button class="btn-small btn-red" onclick="removeCharacter(${index})">‚úï</button>
            `;
        }
    }
}

function removeCharacter(index) {
    gameState.characters[index] = null;
    generateImageGrid();
    gameState.characters.forEach((char, i) => {
        if (char) updateImageSlot(i);
    });
    checkSetupComplete();
}

function checkSetupComplete() {
    const filled = gameState.characters.filter(c => c !== null && c !== undefined).length;
    const btn = document.getElementById('continue-voice-btn');
    
    const allHaveZones = gameState.characters.every(char => {
        if (!char) return true;
        if (char.emoji) return true;
        return char.zones !== null;
    });
    
    if (filled === 10 && allHaveZones) {
        btn.disabled = false;
        btn.style.opacity = '1';
    } else {
        btn.disabled = true;
        btn.style.opacity = '0.5';
    }
}

// =========================
// ZONE EDITOR
// =========================
function openZoneEditor(charIndex) {
    const char = gameState.characters[charIndex];
    if (!char || !char.neutralImg) return;
    
    gameState.currentEditingChar = charIndex;
    gameState.markedZones = char.zones || {};
    gameState.currentZoneToMark = 'upper';
    
    const modal = document.getElementById('zone-editor-modal');
    const canvas = document.getElementById('zone-editor-canvas');
    
    canvas.src = char.neutralImg;
    modal.style.display = 'flex';
    
    document.querySelectorAll('.zone-dot').forEach(dot => dot.remove());
    
    if (char.zones) {
        setTimeout(() => {
            updateZoneStatus();
            renderZoneDots();
        }, 100);
    } else {
        updateZoneStatus();
    }
}

function updateZoneStatus() {
    const zones = ['upper', 'middle', 'lower'];
    const zoneNames = {upper: 'UPPER ZONE', middle: 'MIDDLE ZONE', lower: 'LOWER ZONE'};
    const zoneColors = {upper: '#00ff88', middle: '#00ddff', lower: '#ff0066'};
    
    const markedCount = Object.keys(gameState.markedZones).length;
    
    if (markedCount < 3) {
        gameState.currentZoneToMark = zones[markedCount];
        document.getElementById('current-zone-name').innerText = zoneNames[gameState.currentZoneToMark];
        document.getElementById('current-zone-name').style.color = zoneColors[gameState.currentZoneToMark];
        document.getElementById('save-zones-btn').disabled = true;
    } else {
        document.getElementById('zone-status').innerHTML = '<span style="color: #00ff88;">‚úì ALL ZONES MARKED</span>';
        document.getElementById('save-zones-btn').disabled = false;
    }
}

function renderZoneDots() {
    document.querySelectorAll('.zone-dot').forEach(dot => dot.remove());
    
    const canvas = document.getElementById('zone-editor-canvas');
    const container = document.getElementById('zone-editor-canvas-container');
    const rect = canvas.getBoundingClientRect();
    const containerRect = container.getBoundingClientRect();
    
    Object.keys(gameState.markedZones).forEach(zone => {
        const pos = gameState.markedZones[zone];
        const dot = document.createElement('div');
        dot.className = `zone-dot ${zone}`;
        
        const x = containerRect.left - container.parentElement.scrollLeft + (rect.width * pos.x / 100) + 10;
        const y = containerRect.top - container.parentElement.scrollTop + (rect.height * pos.y / 100) + 10;
        
        dot.style.left = x + 'px';
        dot.style.top = y + 'px';
        dot.style.position = 'fixed';
        
        document.body.appendChild(dot);
    });
}

document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('zone-editor-canvas');
    
    canvas.addEventListener('click', (e) => {
        if (Object.keys(gameState.markedZones).length >= 3) return;
        
        const rect = canvas.getBoundingClientRect();
        const x = ((e.clientX - rect.left) / rect.width) * 100;
        const y = ((e.clientY - rect.top) / rect.height) * 100;
        
        gameState.markedZones[gameState.currentZoneToMark] = { x, y };
        
        updateZoneStatus();
        renderZoneDots();
    });
});

function resetZones() {
    gameState.markedZones = {};
    gameState.currentZoneToMark = 'upper';
    updateZoneStatus();
    document.querySelectorAll('.zone-dot').forEach(dot => dot.remove());
    document.getElementById('save-zones-btn').disabled = true;
}

function saveZones() {
    if (gameState.currentEditingChar !== null && Object.keys(gameState.markedZones).length === 3) {
        gameState.characters[gameState.currentEditingChar].zones = {...gameState.markedZones};
        document.getElementById('zone-editor-modal').style.display = 'none';
        
        document.querySelectorAll('.zone-dot').forEach(dot => dot.remove());
        
        gameState.markedZones = {};
        gameState.currentZoneToMark = 'upper';
        
        checkSetupComplete();
    }
}

// =========================
// VOICE SETUP
// =========================
function showVoiceSetup() {
    document.getElementById('setup-screen').classList.add('hidden');
    document.getElementById('voice-setup-screen').classList.remove('hidden');
    generateVoicePanels();
}

function generateVoicePanels() {
    const container = document.getElementById('voice-panels');
    container.innerHTML = '';
    
    gameState.characters.forEach((char, index) => {
        if (!char) return;
        
        const panel = document.createElement('div');
        panel.className = 'voice-panel';
        
        const displayName = char.name || `Character ${index + 1}`;
        const displayImage = char.neutralImg 
            ? `<img src="${char.neutralImg}" style="width: 80px; height: 80px; border-radius: 5px; object-fit: cover; border: 2px solid #00ff88;">`
            : `<div style="font-size: 60px;">${char.emoji}</div>`;
        
        panel.innerHTML = `
            <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 15px;">
                ${displayImage}
                <div>
                    <div style="font-size: 20px; font-weight: bold; color: #00ff88;">${displayName}</div>
                    <div style="font-size: 14px; opacity: 0.8; color: #00ddff;">${char.isBoss ? 'üî• BOSS' : 'Level ' + char.level}</div>
                </div>
            </div>
            
            <div class="voice-row">
                <span style="color: #00ff88;">Hit Reaction Voice</span>
                <div>
                    <button class="btn-small" onclick="recordVoice(${index})" id="record-${index}">üé§ REC</button>
                    <button class="btn-small btn-blue" onclick="playVoice(${index})" id="play-${index}" style="display:none;">‚ñ∂Ô∏è</button>
                </div>
            </div>
        `;
        
        container.appendChild(panel);
    });
}

async function recordVoice(charIndex) {
    const btn = document.getElementById(`record-${charIndex}`);
    const playBtn = document.getElementById(`play-${charIndex}`);
    
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const recorder = new MediaRecorder(stream);
        const chunks = [];
        
        btn.innerHTML = '‚è∫Ô∏è<span class="recording-indicator"></span>';
        btn.disabled = true;
        
        recorder.ondataavailable = e => chunks.push(e.data);
        recorder.onstop = () => {
            const blob = new Blob(chunks, { type: 'audio/webm' });
            gameState.characters[charIndex].voices.hit = URL.createObjectURL(blob);
            
            btn.innerHTML = '‚úì DONE';
            btn.disabled = false;
            playBtn.style.display = 'inline-block';
            
            stream.getTracks().forEach(track => track.stop());
        };
        
        recorder.start();
        setTimeout(() => recorder.stop(), 2000);
        
    } catch (err) {
        alert('Microphone access denied. Using TTS.');
        btn.innerHTML = 'üé§ REC';
    }
}

function playVoice(charIndex) {
    const url = gameState.characters[charIndex].voices.hit;
    if (url) {
        const audio = new Audio(url);
        audio.play();
    }
}

function showMusicSetup() {
    document.getElementById('voice-setup-screen').classList.add('hidden');
    document.getElementById('music-setup-screen').classList.remove('hidden');
}

// =========================
// GAME START
// =========================
function startGame() {
    document.getElementById('music-setup-screen').classList.add('hidden');
    document.getElementById('game-container').style.display = 'block';
    
    if (gameState.player) {
        gameState.player.loadVideoById(gameState.musicId);
        gameState.player.playVideo();
    }
    
    gameState.currentLevel = 1;
    gameState.score = 0;
    gameState.combo = 0;
    gameState.ammo = gameState.maxAmmo;
    
    startLevel();
}

function startLevel() {
    updateUI();
    clearCharacters();
    
    const levelTime = gameState.currentLevel <= 3 ? 30 : 
                      gameState.currentLevel <= 6 ? 45 : 60;
    gameState.timeLeft = levelTime;
    
    spawnWave();
    startTimer();
}

function startTimer() {
    if (gameState.timerInterval) clearInterval(gameState.timerInterval);
    
    gameState.timerInterval = setInterval(() => {
        gameState.timeLeft--;
        document.getElementById('timer-display').innerText = `TIME: ${gameState.timeLeft}`;
        
        if (gameState.timeLeft <= 0) {
            clearInterval(gameState.timerInterval);
            gameOver();
        }
    }, 1000);
}

function spawnWave() {
    const char = gameState.characters[gameState.currentLevel - 1];
    if (!char) return;
    
    const count = gameState.currentLevel <= 3 ? 1 : 
                  gameState.currentLevel <= 6 ? 2 : 3;
    
    for (let i = 0; i < count; i++) {
        setTimeout(() => spawnCharacter(char, i), i * 1000);
    }
}

function spawnCharacter(charData, index) {
    const char = document.createElement('div');
    char.className = 'character' + (charData.isBoss ? ' boss' : '');
    char.id = 'char-' + Date.now() + '-' + index;
    
    if (charData.neutralImg) {
        char.innerHTML = `
            <img src="${charData.neutralImg}" class="character-img">
            <img src="${charData.reactionImg}" class="character-reaction">
        `;
    } else {
        char.innerHTML = `<div class="character-emoji">${charData.emoji}</div>`;
    }
    
    const startX = 20 + Math.random() * 60;
    char.style.left = startX + '%';
    char.style.top = '15%';
    
    const itemsNeeded = gameState.currentLevel <= 3 ? 2 :
                        gameState.currentLevel <= 6 ? 4 :
                        gameState.currentLevel <= 9 ? 6 : 10;
    
    const needs = {};
    const zones = ['upper', 'middle', 'lower'];
    zones.forEach(zone => {
        const items = gameState.zoneNeeds[zone];
        needs[zone] = items[Math.floor(Math.random() * items.length)];
    });
    
    const needDisplay = document.createElement('div');
    needDisplay.className = 'character-need';
    needDisplay.innerHTML = Object.values(needs).map(item => gameState.projectileEmojis[item]).join(' ');
    char.appendChild(needDisplay);
    
    const progress = document.createElement('div');
    progress.className = 'character-progress';
    progress.innerHTML = '<div class="character-progress-fill" style="width: 0%"></div>';
    char.appendChild(progress);
    
    if (charData.zones) {
        zones.forEach(zone => {
            const marker = document.createElement('div');
            marker.className = `zone-marker ${zone}`;
            marker.style.left = charData.zones[zone].x + '%';
            marker.style.top = charData.zones[zone].y + '%';
            char.appendChild(marker);
        });
    }
    
    document.getElementById('game-container').appendChild(char);
    
    const charState = {
        element: char,
        data: charData,
        needs: needs,
        hits: 0,
        totalNeeded: itemsNeeded,
        startX: startX,
        currentX: startX,
        direction: Math.random() > 0.5 ? 1 : -1,
        movePattern: gameState.currentLevel <= 3 ? 'horizontal' :
                     gameState.currentLevel <= 6 ? 'wave' : 'complex'
    };
    
    gameState.activeCharacters.push(charState);
    animateCharacter(charState);
}

function animateCharacter(charState) {
    let frame = 0;
    
    const animate = () => {
        if (!document.getElementById(charState.element.id)) return;
        
        frame++;
        
        if (charState.movePattern === 'horizontal') {
            charState.currentX += 0.5 * charState.direction;
            if (charState.currentX > 80 || charState.currentX < 20) {
                charState.direction *= -1;
            }
            charState.element.style.left = charState.currentX + '%';
            
        } else if (charState.movePattern === 'wave') {
            charState.currentX += 0.5 * charState.direction;
            if (charState.currentX > 80 || charState.currentX < 20) {
                charState.direction *= -1;
            }
            const yOffset = Math.sin(frame * 0.05) * 50;
            charState.element.style.left = charState.currentX + '%';
            charState.element.style.top = (15 + yOffset) + 'px';
            
        } else {
            const t = frame * 0.03;
            charState.currentX = 50 + Math.sin(t) * 30;
            const yOffset = Math.cos(t * 2) * 40;
            charState.element.style.left = charState.currentX + '%';
            charState.element.style.top = (15 + yOffset) + 'px';
        }
        
        requestAnimationFrame(animate);
    };
    
    animate();
}

function clearCharacters() {
    gameState.activeCharacters.forEach(char => {
        if (char.element && char.element.parentNode) {
            char.element.parentNode.removeChild(char.element);
        }
    });
    gameState.activeCharacters = [];
}

// =========================
// PROJECTILE SELECTION
// =========================
function selectProjectile(type) {
    gameState.selectedProjectile = type;
    document.querySelectorAll('.projectile-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    document.querySelector(`[data-type="${type}"]`).classList.add('active');
    updateSuggestions();
}

function updateSuggestions() {
    document.querySelectorAll('.projectile-btn').forEach(btn => {
        btn.classList.remove('suggested');
    });
    
    const needed = new Set();
    gameState.activeCharacters.forEach(char => {
        Object.values(char.needs).forEach(item => needed.add(item));
    });
    
    needed.forEach(type => {
        const btn = document.querySelector(`[data-type="${type}"]`);
        if (btn && !btn.classList.contains('active')) {
            btn.classList.add('suggested');
        }
    });
}

// =========================
// MAGAZINE SYSTEM
// =========================
function updateAmmoDisplay() {
    document.getElementById('ammo-count').innerText = `${gameState.ammo}/${gameState.maxAmmo}`;
    
    const bars = document.querySelectorAll('.ammo-bar');
    bars.forEach((bar, i) => {
        bar.classList.remove('active', 'reloading');
        if (i < gameState.ammo) {
            bar.classList.add('active');
        }
    });
}

function reload() {
    if (gameState.isReloading) return;
    
    gameState.isReloading = true;
    const bars = document.querySelectorAll('.ammo-bar');
    
    bars.forEach(bar => {
        bar.classList.add('reloading');
    });
    
    setTimeout(() => {
        gameState.ammo = gameState.maxAmmo;
        gameState.isReloading = false;
        updateAmmoDisplay();
    }, 2000);
}

// =========================
// LOB SLINGSHOT PHYSICS (Angry Birds Style)
// =========================
let isDragging = false;
let dragStart = { x: 0, y: 0 };
let basePos = { x: 0, y: 0 };
let ghost = null;

function initSlingshot() {
    const node = document.getElementById('slingshot-hologram');
    const rect = node.getBoundingClientRect();
    basePos = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
}

window.addEventListener('resize', initSlingshot);
setTimeout(initSlingshot, 100);

window.addEventListener('touchstart', e => {
    if (gameState.isReloading) return;
    
    const t = e.touches[0];
    isDragging = true;
    dragStart = { x: t.clientX, y: t.clientY };
    initSlingshot();
    
    ghost = document.createElement('div');
    ghost.className = 'ghost';
    ghost.innerHTML = gameState.projectileEmojis[gameState.selectedProjectile];
    document.body.appendChild(ghost);
});

window.addEventListener('touchmove', e => {
    if (!isDragging || gameState.isReloading) return;
    e.preventDefault();
    
    const t = e.touches[0];
    
    // Calculate pull vector
    const dx = dragStart.x - t.clientX;
    const dy = dragStart.y - t.clientY;
    const dist = Math.min(Math.sqrt(dx*dx + dy*dy), 200);
    const angle = Math.atan2(dy, dx);
    
    // Position ghost at pull point
    ghost.style.left = (dragStart.x - dx) + 'px';
    ghost.style.top = (dragStart.y - dy) + 'px';
    
    updateBands(dragStart.x - dx, dragStart.y - dy);
    showLobTrajectory(dx, dy);
});

window.addEventListener('touchend', e => {
    if (!isDragging || gameState.isReloading) return;
    isDragging = false;
    
    const t = e.changedTouches[0];
    const vx = (dragStart.x - t.clientX) * 0.5;
    const vy = (dragStart.y - t.clientY) * 0.5;
    
    if (ghost) ghost.remove();
    clearBands();
    clearTrajectory();
    
    if (Math.abs(vy) > 10 || Math.abs(vx) > 10) {
        launchLob(vx, vy);
    }
});

// Mouse support
window.addEventListener('mousedown', e => {
    if (gameState.isReloading) return;
    
    isDragging = true;
    dragStart = { x: e.clientX, y: e.clientY };
    initSlingshot();
    
    ghost = document.createElement('div');
    ghost.className = 'ghost';
    ghost.innerHTML = gameState.projectileEmojis[gameState.selectedProjectile];
    document.body.appendChild(ghost);
});

window.addEventListener('mousemove', e => {
    if (!isDragging || gameState.isReloading) return;
    
    const dx = dragStart.x - e.clientX;
    const dy = dragStart.y - e.clientY;
    
    ghost.style.left = (dragStart.x - dx) + 'px';
    ghost.style.top = (dragStart.y - dy) + 'px';
    
    updateBands(dragStart.x - dx, dragStart.y - dy);
    showLobTrajectory(dx, dy);
});

window.addEventListener('mouseup', e => {
    if (!isDragging || gameState.isReloading) return;
    isDragging = false;
    
    const vx = (dragStart.x - e.clientX) * 0.5;
    const vy = (dragStart.y - e.clientY) * 0.5;
    
    if (ghost) ghost.remove();
    clearBands();
    clearTrajectory();
    
    if (Math.abs(vy) > 10 || Math.abs(vx) > 10) {
        launchLob(vx, vy);
    }
});

function updateBands(tx, ty) {
    const bl = document.getElementById('band-l');
    const br = document.getElementById('band-r');
    const angle = Math.atan2(ty - basePos.y, tx - basePos.x);
    const dist = Math.sqrt((tx - basePos.x)**2 + (ty - basePos.y)**2);
    
    bl.style.display = 'block';
    br.style.display = 'block';
    bl.style.left = basePos.x + 'px';
    bl.style.top = basePos.y + 'px';
    bl.style.width = dist + 'px';
    bl.style.transform = `rotate(${angle}rad)`;
    
    br.style.left = basePos.x + 'px';
    br.style.top = basePos.y + 'px';
    br.style.width = dist + 'px';
    br.style.transform = `rotate(${angle}rad)`;
}

function clearBands() {
    document.getElementById('band-l').style.display = 'none';
    document.getElementById('band-r').style.display = 'none';
}

function showLobTrajectory(vx, vy) {
    clearTrajectory();
    
    let px = basePos.x;
    let py = basePos.y;
    const gravity = 0.8;
    let velocityX = vx * 0.5;
    let velocityY = vy * 0.5;
    
    // Show only first 8 dots (partial trajectory)
    for (let i = 0; i < 8; i++) {
        px += velocityX;
        py += velocityY;
        velocityY += gravity;
        
        const dot = document.createElement('div');
        dot.className = 'trajectory-dot';
        dot.style.left = px + 'px';
        dot.style.top = py + 'px';
        document.body.appendChild(dot);
        gameState.trajectoryDots.push(dot);
    }
}

function clearTrajectory() {
    gameState.trajectoryDots.forEach(dot => dot.remove());
    gameState.trajectoryDots = [];
}

function launchLob(vx, vy) {
    // Check ammo
    if (gameState.ammo <= 0) {
        reload();
        return;
    }
    
    gameState.ammo--;
    updateAmmoDisplay();
    
    // Auto-reload if empty
    if (gameState.ammo === 0) {
        reload();
    }
    
    const p = document.createElement('div');
    p.className = 'projectile';
    p.innerHTML = gameState.projectileEmojis[gameState.selectedProjectile];
    document.body.appendChild(p);
    
    let px = basePos.x;
    let py = basePos.y;
    let scale = 1.2;
    let velocityX = vx * 0.5;
    let velocityY = vy * 0.5;
    const gravity = 0.8;
    const projectileType = gameState.selectedProjectile;
    
    const fly = setInterval(() => {
        px += velocityX;
        py += velocityY;
        velocityY += gravity; // Add gravity for arc
        scale -= 0.02;
        
        p.style.left = px + 'px';
        p.style.top = py + 'px';
        p.style.transform = `translate(-50%, -50%) scale(${scale}) rotate(${scale * 360}deg)`;
        
        if (scale <= 0.15 || py < 0 || py > window.innerHeight || px < 0 || px > window.innerWidth) {
            clearInterval(fly);
            checkHit(px, py, projectileType);
            p.remove();
        }
    }, 20);
    
    updateSuggestions();
}

function checkHit(x, y, projectileType) {
    let hit = false;
    
    for (let charState of gameState.activeCharacters) {
        const rect = charState.element.getBoundingClientRect();
        
        if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {
            continue;
        }
        
        const relX = ((x - rect.left) / rect.width) * 100;
        const relY = ((y - rect.top) / rect.height) * 100;
        
        let closestZone = null;
        let minDist = Infinity;
        
        Object.keys(charState.data.zones).forEach(zoneName => {
            const zone = charState.data.zones[zoneName];
            const dist = Math.sqrt(
                Math.pow(relX - zone.x, 2) + 
                Math.pow(relY - zone.y, 2)
            );
            
            if (dist < minDist) {
                minDist = dist;
                closestZone = zoneName;
            }
        });
        
        // EASIER SCORING: 50% hit radius (was 30%)
        const hitRadius = 50;
        
        if (minDist <= hitRadius && charState.needs[closestZone] === projectileType) {
            hit = true;
            charState.hits++;
            
            const progress = (charState.hits / charState.totalNeeded) * 100;
            const fill = charState.element.querySelector('.character-progress-fill');
            if (fill) fill.style.width = progress + '%';
            
            showReaction(charState.element);
            playCharacterVoice(charState.data);
            
            const basePoints = closestZone === 'upper' ? 50 : 
                              closestZone === 'middle' ? 100 : 25;
            gameState.combo++;
            const totalPoints = basePoints * gameState.combo;
            gameState.score += totalPoints;
            
            showFloatingText(x, y, `+${totalPoints}`, '#00ff88');
            
            if (charState.hits >= charState.totalNeeded) {
                charState.element.style.transition = 'all 0.5s';
                charState.element.style.transform = 'scale(0) rotate(360deg)';
                charState.element.style.opacity = '0';
                
                setTimeout(() => {
                    charState.element.remove();
                    gameState.activeCharacters = gameState.activeCharacters.filter(c => c !== charState);
                    
                    if (gameState.activeCharacters.length === 0) {
                        levelComplete();
                    }
                }, 500);
                
                gameState.score += 500;
                showFloatingText(rect.left + rect.width/2, rect.top, 'CLEARED! +500', '#ff00ff');
            }
            
            updateUI();
            break;
            
        } else if (minDist <= hitRadius) {
            gameState.combo = 0;
            showFloatingText(x, y, 'WRONG!', '#ff0066');
            updateUI();
            hit = true;
            break;
        }
    }
    
    if (!hit) {
        gameState.combo = 0;
        updateUI();
    }
}

function showReaction(charElement) {
    charElement.classList.add('reacting');
    setTimeout(() => {
        charElement.classList.remove('reacting');
    }, 500);
}

function playCharacterVoice(charData) {
    const voiceUrl = charData.voices.hit;
    
    if (voiceUrl) {
        const audio = new Audio(voiceUrl);
        audio.play();
    } else {
        const msg = new SpeechSynthesisUtterance('Nice hit!');
        window.speechSynthesis.speak(msg);
    }
}

function showFloatingText(x, y, text, color) {
    const ft = document.createElement('div');
    ft.className = 'floating-text';
    ft.innerText = text;
    ft.style.left = x + 'px';
    ft.style.top = y + 'px';
    ft.style.color = color;
    ft.style.textShadow = `0 0 20px ${color}`;
    document.body.appendChild(ft);
    
    setTimeout(() => ft.remove(), 1500);
}

function updateUI() {
    document.getElementById('score-display').innerText = `SCORE: ${gameState.score}`;
    document.getElementById('combo-display').innerText = `COMBO: ${gameState.combo}x`;
    document.getElementById('level-display').innerText = `LEVEL: ${gameState.currentLevel}`;
    updateAmmoDisplay();
}

// =========================
// LEVEL PROGRESSION
// =========================
function levelComplete() {
    clearInterval(gameState.timerInterval);
    
    const bonusTime = gameState.timeLeft * 10;
    gameState.score += bonusTime;
    
    document.getElementById('level-stats').innerHTML = `
        <h2 style="font-size: 36px; margin: 20px 0; color: #00ff88;">LEVEL ${gameState.currentLevel} COMPLETE</h2>
        <p style="font-size: 24px; color: #00ddff;">SCORE: ${gameState.score}</p>
        <p style="font-size: 20px; color: #ff00ff;">TIME BONUS: +${bonusTime}</p>
    `;
    
    document.getElementById('level-complete-screen').classList.remove('hidden');
}

function nextLevel() {
    document.getElementById('level-complete-screen').classList.add('hidden');
    
    gameState.currentLevel++;
    gameState.ammo = gameState.maxAmmo;
    
    if (gameState.currentLevel > 10) {
        victory();
    } else {
        startLevel();
    }
}

function gameOver() {
    clearCharacters();
    
    document.getElementById('game-over-stats').innerHTML = `
        <h2 style="font-size: 32px; margin: 20px 0; color: #ff0066;">REACHED LEVEL ${gameState.currentLevel}</h2>
        <p style="font-size: 28px; color: #00ff88;">FINAL SCORE: ${gameState.score}</p>
    `;
    
    document.getElementById('game-over-screen').classList.remove('hidden');
}

function victory() {
    clearCharacters();
    
    document.getElementById('victory-stats').innerHTML = `
        <h2 style="font-size: 36px; margin: 20px 0; color: #00ff88;">ALL LEVELS COMPLETE</h2>
        <p style="font-size: 32px; color: #ff00ff;">FINAL SCORE: ${gameState.score}</p>
        <p style="font-size: 24px; color: #00ddff;">SYSTEM MASTERED</p>
    `;
    
    document.getElementById('victory-screen').classList.remove('hidden');
}

function restartGame() {
    document.getElementById('game-over-screen').classList.add('hidden');
    gameState.currentLevel = 1;
    gameState.score = 0;
    gameState.combo = 0;
    gameState.ammo = gameState.maxAmmo;
    startLevel();
}

window.addEventListener('load', () => {
    console.log('‚ö° CYBERPUNK CARNIVAL CHAOS INITIALIZED');
});
</script>
</body>
</html>
